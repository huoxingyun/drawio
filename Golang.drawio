<mxfile host="app.diagrams.net" modified="2021-04-06T10:26:27.807Z" agent="5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36" etag="Chsb_4hDV6jlSKq35oI1" version="14.5.3" type="github">
  <diagram id="aqAW1wouMp0uY8OYH8Mo" name="第 1 页">
    <mxGraphModel dx="2340" dy="1140" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="cLW0TqQUn3YsZ3kaBZDo-1" value="内存分配器：在程序启动的时候，我们需要和操作系统申请一块虚拟地址，每个操作系统的计算方法不一样，go在内存管理上类似于cpu的三级&lt;br&gt;缓存设计&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;1. heap：有一个个不同大小的span组成，span有n个page组成，1page=8Kb&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;2. mcentral：内存控制器，分为小于1MB的span块，与大于1MB的span块&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;3. mcache：分为67种大小不一样的span，1~66，最小的span有1个page组成为8Kb，最大的span由4个page组成，大小为32Kb&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;每个sapn中一个object链表&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;例如：1号span，object大小为8byte，1号span中可以切割为1024个8byte大小的object链表&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; n号span，object大小为8*k，n号span中可以切割为m个8*k大小的object链表&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;在我们程序申请内存时，内存分配器会根据所需大小分配合适的object，go对微小的内存申请做了优化，例如小于8byte的变量，&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;会在object内部切割为一个个的小块去使用，减少内存碎片的产生，在垃圾回收的时候，是以span为整体去回收，如果span内&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;的object没有被完全释放，该span可以被放回到mcentral对应的链表中，提供给其他的线程去使用，如果span内完全是空闲的&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;链表如果放回mcentral后一直没有被使用，就会将span归还给heap，heap会将span进行动态的拼接，根据程序需要内存块的大&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;小，去生成不同大小的span，如果heap中的内存块5分钟没有被使用，heap会将内存归还给操作系统，归还的时候，不是真的&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;释放掉虚拟地址的引用，而是接触虚拟地址与物理地址的映射，在下次程序需要内存时，该虚拟地址会触发缺页异常，操作系&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;统会再次映射物理地址给程序使用&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;mcache会绑定一个单独的线程，在此区域申请内存，可以直接从cache中获取，实现了资源的无锁分配，这也是内存分配效率高的原因&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;程序在初始化时，会创建三块内存区域，span、bitmap、arena，整个地址是连续的，垃圾回收依赖连续地址&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;bitmap：用来标记对象的整个生命周期，以便于后续垃圾回收时对内存的处理，大小为4bit，分表用于标记对象的地址，和状&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;态，第一位标记对象地址，是根据内存起始地址计算出来的一个slot（槽位），bitmap的地址是从后网前遍历&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;arena：用来存放真实数据的存放地址&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;在我们申请大量小类型的时候，会因为object利用不足而产生大量内存碎片，所以如果有上述情况时，可以将同种属性的变量，抽象为一&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;个结构体，使得内存在分配上可以是连续的，大内存的分配对内存的利用率也会比较高&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;垃圾回收时，对于object对象，会按page对齐到page的首地址，这样就可以找到对应的span&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;题外话：为什么操作系统需要使用虚拟地址？&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;因为如果我们的程序之间运行在物理地址中，可能会不小心篡改或者读取了，别的程序的数据，这样对我们开发来说是很不友好&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;的，因此，再来聊一聊操作系统，操作系统是介于硬件与软件中间的一层管理软件，对下管理硬件资源，对上为应用程序提供服&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;务，为我们屏蔽了很多硬件实现上和需要注意的细节，为每段程序开辟了一段叫做进程的空间，实现了程序之间的安全和隔离" style="text;align=left;verticalAlign=top;resizable=1;points=[];autosize=1;strokeWidth=1;perimeterSpacing=0;labelBorderColor=none;labelBackgroundColor=none;html=1;fillOpacity=100;fillColor=#f5f5f5;strokeColor=#666666;rounded=0;shadow=0;glass=0;sketch=1;fontColor=#333333;" vertex="1" parent="1">
          <mxGeometry x="40" y="40" width="760" height="520" as="geometry" />
        </mxCell>
        <mxCell id="cLW0TqQUn3YsZ3kaBZDo-2" value="垃圾回收器：&lt;br&gt;&lt;div&gt;1.起初，所有对象默认为白色。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;2.扫描，将可达对象标记为灰色，放入队列。&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;3.依次从队列提取灰色对象，继续扫描。&lt;span&gt;灰色对象自身转为黑色，表示存活。&lt;/span&gt;&lt;span&gt;被灰色所引用对象，同样标记为灰色，放回队列。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;4.扫描结束后，仅剩黑白二色。白色表示待回收。&lt;/div&gt;" style="text;html=1;align=left;verticalAlign=top;resizable=0;points=[];autosize=1;fillColor=#dae8fc;strokeColor=#6c8ebf;sketch=0;" vertex="1" parent="1">
          <mxGeometry x="40" y="600" width="690" height="120" as="geometry" />
        </mxCell>
        <mxCell id="cLW0TqQUn3YsZ3kaBZDo-3" value="调度器：有两个重要的结构&lt;br&gt;&lt;br&gt;&lt;pre style=&quot;box-sizing: border-box ; font-family: , &amp;#34;consolas&amp;#34; , &amp;#34;liberation mono&amp;#34; , &amp;#34;menlo&amp;#34; , monospace ; font-size: 13.6px ; margin-top: 0px ; margin-bottom: 0px ; overflow-wrap: normal ; padding: 16px ; overflow: auto ; line-height: 1.45 ; border-radius: 6px ; word-break: normal ; color: rgb(36 , 41 , 46)&quot;&gt;&lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// stack 描述的是 Go 的执行栈，下界和上界分别为 [lo, hi]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;pl-k&quot; style=&quot;box-sizing: border-box&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;pl-k&quot; style=&quot;box-sizing: border-box&quot;&gt;struct&lt;/span&gt; {&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;lo&lt;/span&gt; &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;hi&lt;/span&gt; &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;&lt;br&gt;}&lt;br&gt;&lt;br&gt;&lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// g 的运行现场&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;pl-k&quot; style=&quot;box-sizing: border-box&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;gobuf&lt;/span&gt; &lt;span class=&quot;pl-k&quot; style=&quot;box-sizing: border-box&quot;&gt;struct&lt;/span&gt; {&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;sp&lt;/span&gt;   &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// sp 寄存器，汇编中的一个概念：始终指向栈顶&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;pc&lt;/span&gt;   &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// pc 寄存器，汇编中的一个概念：存储指向下一条指令的地址&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;g&lt;/span&gt;    &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;guintptr&lt;/span&gt;   &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// g 指针&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;ctxt&lt;/span&gt; unsafe.&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;Pointer&lt;/span&gt; &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 这个似乎是用来辅助 gc 的&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;ret&lt;/span&gt;  sys.&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;Uintreg&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;lr&lt;/span&gt;   &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 这是在 arm 上用的寄存器，不用关心&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;bp&lt;/span&gt;   &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 开启 GOEXPERIMENT=framepointer，才会有这个&lt;/span&gt;&lt;br&gt;}&lt;/pre&gt;&lt;pre style=&quot;box-sizing: border-box ; font-family: , &amp;#34;consolas&amp;#34; , &amp;#34;liberation mono&amp;#34; , &amp;#34;menlo&amp;#34; , monospace ; font-size: 13.6px ; margin-top: 0px ; margin-bottom: 0px ; overflow-wrap: normal ; padding: 16px ; overflow: auto ; line-height: 1.45 ; border-radius: 6px ; word-break: normal ; color: rgb(36 , 41 , 46)&quot;&gt;&lt;span class=&quot;pl-k&quot; style=&quot;box-sizing: border-box&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;pl-k&quot; style=&quot;box-sizing: border-box&quot;&gt;struct&lt;/span&gt; {&lt;br&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 简单数据结构，lo 和 hi 成员描述了栈的下界和上界内存地址&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;stack&lt;/span&gt;       &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;stack&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 在函数的栈增长 prologue 中用 sp 寄存器和 stackguard0 来做比较&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 如果 sp 比 stackguard0 小(因为栈向低地址方向增长)，那么就触发栈拷贝和调度&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 正常情况下 stackguard0 = stack.lo + StackGuard&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 不过 stackguard0 在需要进行调度时，会被修改为 StackPreempt&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 以触发抢占s&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;stackguard0&lt;/span&gt; &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// stackguard1 是在 C 栈增长 prologue 作对比的对象&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 在 g0 和 gsignal 栈上，其值为 stack.lo+StackGuard&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 在其它的栈上这个值是 ~0(按 0 取反)以触发 morestack 调用(并 crash)&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;stackguard1&lt;/span&gt; &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;&lt;br&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;_panic&lt;/span&gt;         &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;_panic&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;_defer&lt;/span&gt;         &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;_defer&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;m&lt;/span&gt;              &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;m&lt;/span&gt;             &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 当前与 g 绑定的 m&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;sched&lt;/span&gt;          &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;gobuf&lt;/span&gt;          &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// goroutine 的现场&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;syscallsp&lt;/span&gt;      &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;        &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// if status==Gsyscall, syscallsp = sched.sp to use during gc&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;syscallpc&lt;/span&gt;      &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;        &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// if status==Gsyscall, syscallpc = sched.pc to use during gc&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;stktopsp&lt;/span&gt;       &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;        &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// expected sp at top of stack, to check in traceback&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;param&lt;/span&gt;          unsafe.&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;Pointer&lt;/span&gt; &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// wakeup 时的传入参数&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;atomicstatus&lt;/span&gt;   &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uint32&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;stackLock&lt;/span&gt;      &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// sigprof/scang lock; TODO: fold in to atomicstatus&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;goid&lt;/span&gt;           &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;int64&lt;/span&gt;  &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// goroutine id&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;waitsince&lt;/span&gt;      &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;int64&lt;/span&gt;  &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// g 被阻塞之后的近似时间&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;waitreason&lt;/span&gt;     &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// if status==Gwaiting&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;schedlink&lt;/span&gt;      &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;guintptr&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;preempt&lt;/span&gt;        &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;bool&lt;/span&gt;     &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 抢占标记，这个为 true 时，stackguard0 是等于 stackpreempt 的&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;throwsplit&lt;/span&gt;     &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;bool&lt;/span&gt;     &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// must not split stack&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;raceignore&lt;/span&gt;     &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;int8&lt;/span&gt;     &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// ignore race detection events&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;sysblocktraced&lt;/span&gt; &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;bool&lt;/span&gt;     &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// StartTrace has emitted EvGoInSyscall about this goroutine&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;sysexitticks&lt;/span&gt;   &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;int64&lt;/span&gt;    &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// syscall 返回之后的 cputicks，用来做 tracing&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;traceseq&lt;/span&gt;       &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uint64&lt;/span&gt;   &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// trace event sequencer&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;tracelastp&lt;/span&gt;     &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;puintptr&lt;/span&gt; &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// last P emitted an event for this goroutine&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;lockedm&lt;/span&gt;        &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;muintptr&lt;/span&gt; &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 如果调用了 LockOsThread，那么这个 g 会绑定到某个 m 上&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;sig&lt;/span&gt;            &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uint32&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;writebuf&lt;/span&gt;       []&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;byte&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;sigcode0&lt;/span&gt;       &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;sigcode1&lt;/span&gt;       &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;sigpc&lt;/span&gt;          &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;gopc&lt;/span&gt;           &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt; &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 创建该 goroutine 的语句的指令地址&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;startpc&lt;/span&gt;        &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt; &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// goroutine 函数的指令地址&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;racectx&lt;/span&gt;        &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;waiting&lt;/span&gt;        &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;sudog&lt;/span&gt;         &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// sudog structures this g is waiting on (that have a valid elem ptr); in lock order&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;cgoCtxt&lt;/span&gt;        []&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uintptr&lt;/span&gt;      &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// cgo traceback context&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;labels&lt;/span&gt;         unsafe.&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;Pointer&lt;/span&gt; &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// profiler labels&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;timer&lt;/span&gt;          &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;timer&lt;/span&gt;         &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// time.Sleep 缓存的定时器&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;pl-c1&quot; style=&quot;box-sizing: border-box&quot;&gt;selectDone&lt;/span&gt;     &lt;span class=&quot;pl-smi&quot; style=&quot;box-sizing: border-box&quot;&gt;uint32&lt;/span&gt;         &lt;span class=&quot;pl-c&quot; style=&quot;box-sizing: border-box&quot;&gt;// 该 g 是否正在参与 select，是否已经有人从 select 中胜出&lt;/span&gt;&lt;br&gt;}&lt;/pre&gt;1. 调度器初始化时会设置一个P的数量，默认为cpu的逻辑核数，" style="text;html=1;align=left;verticalAlign=top;resizable=0;points=[];autosize=1;fillColor=#f5f5f5;strokeColor=#666666;fontColor=#333333;" vertex="1" parent="1">
          <mxGeometry x="40" y="760" width="1010" height="1370" as="geometry" />
        </mxCell>
        <mxCell id="cLW0TqQUn3YsZ3kaBZDo-5" value="&lt;pre style=&quot;box-sizing: border-box ; font-family: , &amp;#34;consolas&amp;#34; , &amp;#34;liberation mono&amp;#34; , &amp;#34;menlo&amp;#34; , monospace ; font-size: 13.6px ; margin-top: 0px ; margin-bottom: 16px ; overflow-wrap: normal ; padding: 16px ; overflow: auto ; line-height: 1.45 ; border-radius: 6px ; color: rgb(36 , 41 , 46)&quot;&gt;&lt;code style=&quot;box-sizing: border-box ; font-family: , &amp;#34;consolas&amp;#34; , &amp;#34;liberation mono&amp;#34; , &amp;#34;menlo&amp;#34; , monospace ; font-size: 13.6px ; padding: 0px ; margin: 0px ; border-radius: 6px ; word-break: normal ; border: 0px ; display: inline ; overflow: visible ; line-height: inherit ; overflow-wrap: normal&quot;&gt;                                                +--------------+&lt;br&gt;                                                |    binded    +-------------------------------------+&lt;br&gt;                                                +-------+------+                                     |&lt;br&gt;+------------------------------------+                  |                                            v                         +------------------------------------+&lt;br&gt;|                                    |                  |                         +------------------------------------+       |                                    |&lt;br&gt;|             +------------------+   |                  |                         |                                    |       |            +------------------+    |&lt;br&gt;|             | Local Run Queue  |   |                  |                         |             +------------------+   |       |            | Global Run Queue |    |&lt;br&gt;|   other P   +-+-+-+-+-+-+-+-+--+   |                  |                         |             | Local Run Queue  |   |       |  schedt    +--+-+-+-+-+-+-+---+    |&lt;br&gt;|               |G|G|G|G|G|G|G|      |                  |                         |    P        +-+-+-+-+-+-+-+-+--+   |       |               |G|G|G|G|G|G|        |&lt;br&gt;|               +-+-+-+-+-+-+-+      |                  |                         |               |G|G|G|G|G|G|G|      |       |               +-+-+-+-+-+-+        |&lt;br&gt;|                ^                   |                  |                         |               +-+-+-+-+-+-+-+      |       |                ^                   |&lt;br&gt;+----------------+-------------------+                  |                         |                ^                   |       +----------------+-------------------+&lt;br&gt;                 |                                      |                         +----------------+-------------------+                        |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      |                                          |                                            |&lt;br&gt;                 |                                      v                                          |                                            |&lt;br&gt;          +------+-------+                             .-.      +----------------+                 |                                            |&lt;br&gt;          |    steal     +----------------------------( M )-----+    runqget     +-----------------+                                            |&lt;br&gt;          +--------------+                             `-&#39;      +----------------+                                                              |&lt;br&gt;                                                        |                                                                                       |&lt;br&gt;                                                        |                                                                           +-----------+-----+&lt;br&gt;                                                        +---------------------------------------------------------------------------+   globrunqget   |&lt;br&gt;                                                        |                                                                           +-----------------+&lt;br&gt;                                                        |&lt;br&gt;                                                        |&lt;br&gt;                                                        |&lt;br&gt;                                                        |&lt;br&gt;                                                        |&lt;br&gt;                                                        |&lt;br&gt;                                             +----------+--------+&lt;br&gt;                                             |   get netpoll g   |&lt;br&gt;                                             +----------+--------+&lt;br&gt;                                                        |&lt;br&gt;                                                        |&lt;br&gt;                                                        |&lt;br&gt;                                                        |&lt;br&gt;                                                        |&lt;br&gt;                                         +--------------+--------------------+&lt;br&gt;                                         |              |                    |&lt;br&gt;                                         |              |                    |&lt;br&gt;                                         |   netpoll    v                    |&lt;br&gt;                                         |             +-+-+-+-+             |&lt;br&gt;                                         |             |G|G|G|G|             |&lt;br&gt;                                         |             +-+-+-+-+             |&lt;br&gt;                                         |                                   |&lt;br&gt;                                         +-----------------------------------+&lt;/code&gt;&lt;/pre&gt;" style="text;html=1;align=left;verticalAlign=top;resizable=0;points=[];autosize=1;" vertex="1" parent="1">
          <mxGeometry x="80" y="2250" width="1390" height="1100" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
